public class Note
{
    // -------------------- 迭代器和集合的区别 --------------------

    // var axes = GetAxes(p);
    // return axes.All(axis => OverlapOnAxis(p, otherP, axis));
    // 性能上需要考虑：
    // 如果 GetAxes(p) 返回的是一个迭代器而不是一个集合，每次调用All方法都会重新枚举它，这可能导致重复的计算

    // 在C#中
    // "集合"通常指的是像数组或List<T>这样的内存中的数据结构，它们存储了元素的集合。
    // 当你对这些集合进行操作时（比如迭代），你是在访问已经存储在内存中的数据。

    // 另一方面，"迭代器"通常是通过实现IEnumerable<T>或IEnumerator<T>接口的对象，
    // 它们提供一种方法来逐个访问集合中的元素，而不需要事先将所有元素都加载到内存中。
    // 迭代器是延迟计算的，这意味着它们的元素是在迭代过程中生成的。
    // IEnumerable<int> numbers = Enumerable.Range(1, 1000000);

    // 当你对迭代器调用像All这样的LINQ扩展方法时，迭代器会从头到尾遍历一遍以评估每个元素是否满足给定的条件。
    // 如果 GetAxes(p) 方法返回一个迭代器，那么每次调用OverlapOnAllAxes方法时，All方法都会使迭代器从头开始遍历。
    // 如果这个迭代器背后涉及到计算成本较高的操作（例如计算多边形的投影轴），这将导致重复的计算，
    // 因为每次调用OverlapOnAllAxes时，迭代器都会重新计算所有轴。

    // 如果你知道你将要多次迭代同一个序列，并且序列的生成成本很高，
    // 那么通常更好的做法是将迭代器转换为一个列表或数组，并对这个集合进行操作。
    // 这可以通过调用 .ToList() 或 .ToArray() 方法来实现。

    // 这会立即计算并存储所有轴
    // var axes = GetAxes(p).ToList();
    // return axes.All(axis => OverlapOnAxis(p, otherP, axis));

    // GetAxes(p).ToList() 首先计算所有轴并将它们存储在列表中。
    // 之后，当你调用All方法时，它只是遍历这个列表，而不是重新计算每个轴。
    // 这样可以避免重复的计算，提高性能。
    // 不过，这也意味着所有的轴都会被加载到内存中，这如果轴的数量非常庞大的话，可能会增加内存的使用。
    
    
    
    // -------------------- LINQ是如何消耗性能的 --------------------
    
    // 1. 委托开销
    //    通常需要传入一个委托（例如，一个lambda表达式）。
    //    每次LINQ查询在某个元素上执行这些委托时，会存在为委托调用建立新的堆栈等消耗。
    
    // 2. 延迟执行与迭代器状态机
    //    LINQ查询是延迟执行的，意味着它们只有在你遍历结果时才真正执行。
    //    为了支持这种延迟执行，编译器生成了一个状态机。
    //    这个状态机管理着迭代的过程，但这也意味着每次你迭代查询结果时都会有额外的状态跟踪和控制流管理开销。
    
    // 3. 多次枚举成本，链式调用产生的中间集合
    //    如果你对一个LINQ查询多次迭代，每次都会重新执行整个查询逻辑。
    //    与之相反，如果你将结果存储在一个列表或数组中，只需要计算一次，后续的迭代就会从这个已经计算好的集合中进行。
    
    // 示例优化：
    // 假设有一个int数组，找出其中所有偶数的平方
    
    // var squares = numbers.Where(n => n % 2 == 0).Select(n => n * n);
    
    // var squares = new List<int>();
    // foreach (var n in numbers)
    // {
    //     if (n % 2 == 0)
    //         squares.Add(n * n);
    // }
}